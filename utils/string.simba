{$DEFINE SRL_STRING_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL/utils.simba}
{$ENDIF}

(*
String
======
String related methods
*)

const
  STR_WHITESPACE = #9#10#11#12#13#32;
  STR_NEW_LINE = #13#10;

(*
String.Len
~~~~~~~~~~~~~~~
.. pascal:: function String.Len(): Int32; 

Returns the length of the string
*)
function String.Len: Int32; 
begin
  Result := Length(Self);
end;

(*
String.Pos
~~~~~~~~~~~~~~~
.. pascal:: function String.Pos(SubStr: String): Int32; 

Returns the position of the position of the first occurance of the substring
*)
function String.Pos(SubStr: String): Int32; 
begin
  Result := System.Pos(SubStr, self);
end;

(*
String.PosR
~~~~~~~~~~~~~~~
.. pascal:: function String.PosR(SubStr: String): Int32; 

Returns the position of the position of the last occurance of the substring
*)
function String.PosR(SubStr: String): Int32;  
var 
  list:TIntegerArray;
begin
  list := System.PosMulti(SubStr, self);
  if Length(list) > 0 then
    Result := list[high(list)]
  else
    Result := 0;
end;

(*
String.PosEx
~~~~~~~~~~~~~~~~~
.. pascal:: function String.PosEx(SubStr: String): TIntegerArray; 

Returns the position of every occurance of the substring
*)
function String.PosEx(SubStr: String): TIntegerArray; 
begin
  Result := System.PosMulti(SubStr, self);
end;


(*
String.Explode
~~~~~~~~~~~~~~~~~~~
.. pascal:: function String.Explode(Delimiter: String): TStringArray; 

Blow up the string at each delimiter into smaller strings
*)
function String.Explode(Delimiter: String): TStringArray; 
begin
  Result := System.Explode(Delimiter, Self);
end;

{*
String.Strip
~~~~~~~~~~~~~~~~~
.. pascal:: function String.Strip(Chars:String = STR_WHITESPACE): String; 

Return a copy of the string with leading and trailing characters removed.
*}
function String.Strip(Chars:String = STR_WHITESPACE): String; 
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Lo <= Hi) and (System.Pos(Self[Lo],Chars) <> 0) do Inc(Lo);
  while (Hi >= 1)  and (System.Pos(Self[Hi],Chars) <> 0) do Dec(Hi);
  Result := Copy(Self, Lo, Hi-Lo+1);
end;


{*
String.StripL
~~~~~~~~~~~~~~~~~
.. pascal:: function String.StripL(Chars:String = STR_WHITESPACE): String; 

Return a copy of the string with leading characters removed.
*}
function String.StripL(Chars:String = STR_WHITESPACE): String; 
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Lo <= Hi) and (System.Pos(Self[Lo],Chars) <> 0) do Inc(Lo);
  Result := Copy(Self, Lo, Hi-Lo+1);
end;  


{*
String.StripR
~~~~~~~~~~~~~~~~~
.. pascal:: function String.StripR(Chars:String = STR_WHITESPACE): String; 

Return a copy of the string with trailing characters removed.
*}
function String.StripR(Chars:String = STR_WHITESPACE): String; 
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Hi >= 1) and (System.Pos(Self[Hi],Chars) <> 0) do Dec(Hi);
  Result := Copy(Self, Lo, Hi-Lo+1);
end;

function String.ExtractNumber(DefaultValue: Int64 = -1): Int64; 
begin
  Result := StrToIntDef(ExtractFromStr(Self, Numbers), DefaultValue);
end;

(*
String.ExtractNumbers
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function String.ExtractNumbers(): TExtendedArray; 

Extract all the numbers found in the string, as there could be floating point numbers 
as well it reutnrs a TExtendedArray.
*)
function String.ExtractNumbers(): TExtendedArray; 
var
  i,c,l:Int32;
  Tmp: TStringArray;
begin
  L := Length(Self);
  for i:=1 to Length(Self) do
  begin
    if Self[i].IsInteger() then
    begin
      Tmp += Self[i];
      while (Inc(i) <= L) and (Self[i].IsInteger()) do Tmp[c] += Self[i];
      if (i <= L) and (Self[i] = '.') then
      begin
        Tmp[c] += Self[i];
        while (Inc(i) <= L) and (Self[i].IsInteger()) do Tmp[c] += Self[i];
      end;
      if (i > L) then Break;
      Inc(c);
    end;
  end;

  SetLength(Result, Length(tmp));
  for i:=0 to High(Tmp) do
    Result[i] := StrToFloat(Tmp[i]);
end;

(*
String.ExtractNumbersEx
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function String.ExtractNumbersEx(): TExtendedArray; 

Extract all the numbers found in the string, this time every number 
ends up in each their index. For example ``'1234'`` would return ``[1,2,3,4]``
*)
function String.ExtractNumbersEx(): TExtendedArray; 
var
  i, c: Int32;
begin
  SetLength(Result, 0);
  c := 0;

  for i := 1 to High(Self) do
    if (Self[i] in ['0'..'9']) then
    begin
      SetLength(Result, c + 1);
      Result[c] := StrToInt(Self[i]);
      Inc(c);
    end;
end;

(*
String.FileExt
~~~~~~~~~~~~~~~~~~
.. pascal:: function String.FileExt(): String; 

Returns the file extension
*)
function String.FileExt(): String; 
begin
  Result := ExtractFileExt(Self);
  Delete(Result,1,1);
end;

(*
String.FileName
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function String.FileName(): String; 

Returns the file name
*)
function String.FileName(): String; 
begin
  if Length(Self) <> 0 then
    Result := Self.Explode('.')[0];
end;

operator in (Right: TStringArray; Left: String): Boolean;
var
  i: Int32;
begin
  for i := 0 to High(Right) do
    if System.Pos(Right[i], Left) > 0 then
      Exit(True);
end;

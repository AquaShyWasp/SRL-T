{$DEFINE SRL_TBOXARRAY_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL/utils.simba}
{$ENDIF}

(*
TBoxArray
=========
TBoxArray related methods
*)

function TBoxArray.Combine(Other: TBoxArray): TBoxArray; 
begin
  SetLength(Result, Length(Self) + Length(Other));
  if Length(self) > 0 then
    MemMove(self[0], result[0], Length(self)*SizeOf(self[0]));
  if Length(Other) > 0 then
    MemMove(Other[0], result[Length(Self)], Length(Other)*SizeOf(Other[0]));
end;

function TBoxArray.Equals(Other:TBoxArray): Boolean; 
begin
  if (Length(Self) <> Length(Other)) then Exit(False);
  if (Length(Self) = 0) then Exit(True);
  Result := CompareMem(Self[0], Other[0], length(self)*SizeOf(self[0]));     
end;

procedure TBoxArray.SortFromMidPoint(From: TPoint);
var
  I, L: Integer;
  Mid: TPoint;
  weights: TIntegerArray;
begin
  L := High(Self);
  if (L <= 0) then
    Exit;

  SetLength(weights, L + 1);
  for i := 0 To L do
  begin
    Mid := MiddleBox(Self[i]);
    weights[i] := Round(Sqr(From.X - Mid.X) + Sqr(From.Y - Mid.Y));
  end;

  Self.Sort(weights, True);
end;

procedure TBoxArray.ModifySide(side:String='x1'; change:Int32=1);
var i:Int32;
begin
  side := LowerCase(side);
  if Length(side) < 2 then Exit();
  SetLength(side, 2);
  for i:=0 to High(self) do
    case Side of
      'x1': self[i].x1 += change;
      'y1': self[i].y1 += change;
      'x2': self[i].x2 += change;
      'y2': self[i].y2 += change;
    end;
end;

function TBoxArray.Offset(pt:TPoint): TBoxArray;
var i:Int32;
begin
  SetLength(Result, Length(Self));
  
  for i:=0 to High(self) do
  begin
    Result[i].X1 := Self[I].X1 + pt.x;
    Result[i].Y1 := Self[I].Y1 + pt.y;
    Result[i].X2 := Self[I].X2 + pt.x;
    Result[i].Y2 := Self[I].Y2 + pt.y;
  end;
end;

function TBoxArray.Merge(): TBox; 
var i:Int32;
begin
  if Length(Self) = 0 then
    Exit;

  Result := Self[0];
  for i:=1 to High(self) do
    Result := Result + Self[i];
end;

procedure TBoxArray.SortByX(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Length(Self) = 0 then
    Exit;

  SetLength(Weights, Length(Self));
  for I := 0 to High(Weights) do
    Weights[I] := Self[I].X1;

  Self.Sort(Weights, LowToHi);
end;

procedure TBoxArray.SortByY(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Length(Self) = 0 then
    Exit;

  SetLength(Weights, Length(Self));
  for I := 0 to High(Weights) do
    Weights[I] := Self[I].Y1;

  Self.Sort(Weights, LowToHi);
end;

// Sorts column wise
// Example: [0][1][2][3]
//          [4][5][6]
procedure TBoxArray.SortByXY(Tolerance: Int32 = 0);
var
  I, J: Int32;
  Weights: TIntegerArray;
  Means: TPointArray;
begin
  if Length(Self) = 0 then
    Exit;
  
  SetLength(Weights, Length(Self)); 
  SetLength(Means, Length(Self));
  for I := 0 to High(Self) do
    Means[I] := Self[I].Middle();

  for I := 0 to High(Self) do
  begin
    Weights[I] := Means[I].X + (Means[I].Y * 1000);
    if Tolerance = 0 then
      Continue;
      
    for J := 0 to High(Self) do
      if Abs(Means[I].Y - Means[J].Y) < Tolerance then
        Weights[I] := Means[I].X + (Means[J].Y * 1000);
  end;
    
  Self.Sort(Weights, True);
end;

function TBoxArray.Middles: TPointArray; 
var
  I: Int32;
begin
  SetLength(Result, Length(Self));
  for I := 0 to High(Self) do
    Result[I] := Self[I].Middle();
end;

function Grid(Columns, Rows, Width, Height: Int32; Spacing, Start: TPoint): TBoxArray;
var
  I: Int32;
begin
  Start.X += (Width div 2);
  Start.Y += (Height div 2);

  Spacing.X += Width;
  Spacing.Y += Height;

  SetLength(Result, Columns * Rows);

  for I := 0 to High(Result) do
  begin
    Result[I].X1 := Start.X + I mod Columns * Spacing.X - Width div 2;
    Result[I].Y1 := Start.Y + I div Columns * Spacing.Y - Height div 2;
    Result[I].X2 := Result[I].X1 + Width;
    Result[I].Y2 := Result[I].Y1 + Height;
  end;
end;
